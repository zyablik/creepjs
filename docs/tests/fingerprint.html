<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <script type="text/javascript">

      const hashMini = (x) => {
        const json = `${JSON.stringify(x)}`
        const hash = json.split('').reduce((hash, char, i) => {
          return Math.imul(31, hash) + json.charCodeAt(i) | 0
        }, 0x811c9dc5)
        return ('0000000' + (hash >>> 0).toString(16)).substr(-8)
      }

      async function collect_fp() {
        battery = (await navigator?.getBattery?.());

        hasTouch = () => {
          try {
            return 'ontouchstart' in window && !!document.createEvent('TouchEvent')
          } catch (err) {
            return false
          }
        }

        fp = {
          navigator: {
            userAgent: navigator?.userAgent,

            userAgentData: (await navigator?.userAgentData?.getHighEntropyValues(
                ['architecture', 'bitness', 'formFactors', 'fullVersionList', 'model', 'platformVersion', 'uaFullVersion', 'wow64' ])), // brands, mobile, platform

            platform: navigator?.platform,

            webdriver: navigator?.webdriver,
            appVersion: navigator?.appVersion,
            deviceMemory: navigator?.deviceMemory,
            hardwareConcurrency: navigator?.hardwareConcurrency,
            language: navigator?.language,
            languages: navigator?.languages,
            maxTouchPoints: navigator?.maxTouchPoints,
            onLine: navigator?.onLine,

            vendor: navigator?.vendor,

            connection: {
              downlink: navigator?.connection?.downlink,
              downlinkMax: navigator?.connection?.downlinkMax || navigator?.connection?.downlink,
              effectiveType: "k" + navigator?.connection?.effectiveType?.toUpperCase(),
              rtt: navigator?.connection?.rtt,
              saveData: navigator?.connection?.saveData,
              type: navigator?.connection?.type || "unknown",
            },

            plugings: null,
            mimeTypes: null,

            battery: {
              charging: battery?.charging,
              level: battery?.level,
              chargingTime: battery?.chargingTime == Infinity ? 1e308 : battery?.chargingTime,
              dischargingTime: battery?.dischargingTime == Infinity ? 1e308 : battery?.dischargingTime,
            },

            bluetooth: {
              bluetooth: String(navigator.bluetooth),
              availability: (await navigator.bluetooth?.getAvail1ability?.())
            },

            storage: {
              storage: String(navigator.storage),
              quota: (await navigator?.storage?.estimate?.())?.quota,
              usage: (await navigator?.storage?.estimate?.())?.usage,
            },

            mediaDevices: null,

            gpu: {
              info: {},
              features: [],
              limits: {}
            },

            properties: Object.keys(Object.getPrototypeOf(navigator)) // hashMini(properties.join(', ')),
          },

          performance: {
            memory: {
              jsHeapSizeLimit: performance?.memory?.jsHeapSizeLimit,
              totalJSHeapSize: performance?.memory?.totalJSHeapSize,
              usedJSHeapSize: performance?.memory?.usedJSHeapSize,
            }
          },

          screen: {
            orientation: {
              type: screen?.orientation?.type.replace(/-/, "_"),
              angle: screen?.orientation?.angle,
            },
            availHeight: screen.availHeight,
            availWidth: screen.availWidth,
            pixelDepth: screen.pixelDepth,
            height: screen.height,
            width: screen.width,
            availTop: screen.availTop,
            availLeft: screen.availLeft,
            colorDepth: screen.colorDepth,

            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight,
            outerWidth: window.outerWidth,
            outerHeight: window.outerHeight,
            screenX: window.screenX,
            screenY: window.screenY,
            devicePixelRatio: window.devicePixelRatio,

//            physicalPixelWidth: screen.physicalPixelWidth,
//            physicalPixelHeight: screen.physicalPixelHeight,

            visualViewport: {
              width: window.visualViewport?.width,
              height: window.visualViewport?.width,
            },

            domRectViewport: {
               width: document.body.getBoundingClientRect().width,
               height: document.body.getBoundingClientRect().height,
            },

          },

          misc: {
            window_chrome: String(window.chrome),
            chrome_runtime: String(chrome?.runtime),
            chrome_app: String(chrome?.app),
            window_ontouchstart: String(window.ontouchstart),
            touch_event: hasTouch(),
            window_keys: Object.getOwnPropertyNames(window),
          },

          intl: {
            locale: (new Intl.Collator)?.resolvedOptions?.()?.locale,
            toLocaleString_undefined: (1).toLocaleString?.(undefined, { style: 'currency', currency: 'USD', currencyDisplay: 'name'}),
            toLocaleString_lang: (1).toLocaleString?.(navigator.language, { style: 'currency', currency: 'USD', currencyDisplay: 'name'}),

            timezone: Intl.DateTimeFormat()?.resolvedOptions?.().timeZone,
            offset: (new Date()).getTimezoneOffset?.(),
          },

          webgl: {
            parameters: {},
            extensions_gl1: [],
            extensions_gl2: [],
            precisions: {},
          },

          voices: Array.from(speechSynthesis?.getVoices() ||[]).map((voice) => ({
            name: voice.name,
            voiceURI: voice.voiceURI,
            lang: voice.lang,
            localService: voice.localService,
            default: voice.default
          })),

          audioCodecs: {},

          videoCodecs: {},

          webrtc: {
            offer: {
              audio: {
                media_line: null,
                rtpmap_lines: []
              },

              video: {
                media_line: null,
                rtpmap_lines: []
              },
            },

            addresses: null,
            sdp: null,
            connectionLineIpAddress: null,
            candidateIpAddress: null,
          },

          fonts: [],

        };

        fp.navigator.plugins = Array.from(navigator.plugins || []).map((p) => ({
          name: p.name,
          filename: p.filename,
          description: p.description,
          mimeTypes: Array.from(p || []).map(mt => ({
            type: mt.type,
            description: mt.description,
            suffixes: mt.suffixes
          }))
        }));

        fp.navigator.mimeTypes = Array.from(navigator.mimeTypes || []).map(mt => ({
          type: mt.type,
          description: mt.description,
          suffixes: mt.suffixes,
          enabledPlugin: mt.enabledPlugin && mt.enabledPlugin.name ? mt.enabledPlugin.name : null
        }));

        media_devices = await navigator?.mediaDevices?.enumerateDevices?.() || [];

        fp.navigator.mediaDevices = media_devices.map((d) => ({
          deviceId: d.deviceId,
          groupId: d.groupId,
          kind: d.kind,
          label: d.label
        }));

        // webgpu
        gpu_adapter = await navigator.gpu?.requestAdapter?.()

        for (let key in gpu_adapter?.info) {
          fp.navigator.gpu.info[key] = gpu_adapter.info[key]
        }

        for (let key in gpu_adapter?.limits) {
          fp.navigator.gpu.limits[key] = gpu_adapter.limits[key]
        }

        fp.navigator.gpu.features = Array.from(gpu_adapter?.features)

        // webgl
        canvas1 = document.createElement("canvas");
        gl1_context = canvas1.getContext("webgl");
        fp.webgl.extensions_gl1 = gl1_context.getSupportedExtensions();

        canvas2 = document.createElement("canvas");
        gl2_context = canvas2.getContext("webgl2");
        fp.webgl.extensions_gl2 = gl2_context.getSupportedExtensions();

        ["ALIASED_LINE_WIDTH_RANGE", "ALIASED_POINT_SIZE_RANGE"].forEach(key => {
          try {
            range = gl2_context.getParameter(gl2_context[key])
            fp.webgl.parameters[key] = {min: range[0], max: range[1]}
          } catch (e) {
            fp.webgl.parameters[key] = null
          }
        });

        ["MAX_3D_TEXTURE_SIZE", "MAX_ARRAY_TEXTURE_LAYERS",
         "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", "MAX_COLOR_ATTACHMENTS", "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
         "MAX_COMBINED_UNIFORM_BLOCKS", "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", "MAX_CUBE_MAP_TEXTURE_SIZE", "MAX_DRAW_BUFFERS",
         "MAX_ELEMENTS_INDICES", "MAX_ELEMENTS_VERTICES", "MAX_ELEMENT_INDEX", "MAX_FRAGMENT_INPUT_COMPONENTS",
         "MAX_FRAGMENT_UNIFORM_BLOCKS", "MAX_FRAGMENT_UNIFORM_COMPONENTS", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_PROGRAM_TEXEL_OFFSET",
         "MAX_RENDERBUFFER_SIZE", "MAX_SAMPLES", "MAX_SERVER_WAIT_TIMEOUT", "MAX_TEXTURE_IMAGE_UNITS",
         "MAX_TEXTURE_LOD_BIAS", "MAX_TEXTURE_SIZE", "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
         "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", "MAX_UNIFORM_BLOCK_SIZE", "MAX_UNIFORM_BUFFER_BINDINGS",
         "MAX_VARYING_COMPONENTS", "MAX_VARYING_VECTORS", "MAX_VERTEX_ATTRIBS", "MAX_VERTEX_OUTPUT_COMPONENTS",
         "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_VERTEX_UNIFORM_BLOCKS", "MAX_VERTEX_UNIFORM_COMPONENTS", "MAX_VERTEX_UNIFORM_VECTORS",
         "MIN_PROGRAM_TEXEL_OFFSET", ].forEach(key =>
        {
          try {
            fp.webgl.parameters[key] = gl2_context.getParameter(gl2_context[key])
          } catch (e) {
            fp.webgl.parameters[key] = null
          }
        });

        key = "MAX_VIEWPORT_DIMS";
        try {
          dims = gl2_context.getParameter(gl2_context[key])
          fp.webgl.parameters[key] = {width: dims[0], height: dims[1]}
        } catch (e) {
          fp.webgl.parameters[key] = null
        }

        renderer_info = gl1_context.getExtension("WEBGL_debug_renderer_info");

//        try {
          fp.webgl.parameters.UNMASKED_RENDERER_WEBGL = gl1_context.getParameter(renderer_info.UNMASKED_RENDERER_WEBGL)
          fp.webgl.parameters.UNMASKED_VENDOR_WEBGL = gl1_context.getParameter(renderer_info.UNMASKED_VENDOR_WEBGL)
          ani_ext = gl1_context.getExtension('EXT_texture_filter_anisotropic')
          if(ani_ext) {
            fp.webgl.parameters.MAX_TEXTURE_MAX_ANISOTROPY_EXT = gl1_context.getParameter(ani_ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
          } else {
            fp.webgl.parameters.MAX_TEXTURE_MAX_ANISOTROPY_EXT = null
          }
//        } catch (e) {};

        ["VERTEX_SHADER", "FRAGMENT_SHADER"].forEach(shader_type => {
          fp.webgl.precisions[shader_type.toLowerCase()] = {};
          ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"].forEach(precision_type => {
             precision = gl1_context.getShaderPrecisionFormat(gl1_context[shader_type], gl1_context[precision_type])
             fp.webgl.precisions[shader_type.toLowerCase()][precision_type.toLowerCase()] = {
               precision: precision.precision,
               max: precision.rangeMax,
               min: precision.rangeMin,
             }
          });
        });

        // webrtc

        async function get_ice_addresses(connection) {
          return new Promise((resolve) => {
            addresses = []
            setTimeout(() => { return resolve(["timeout"]) }, 3000)

            connection.onicecandidate = (event) => {
              if(event.candidate) {
                addresses.push(event.candidate.address)
              } else {
                connection.onicecandidate = null
                resolve(addresses)
              }
            }
          })
        }

        config = {
          iceCandidatePoolSize: 1,
          iceServers: [{ urls: [ 'stun:stun4.l.google.com:19302', 'stun:stun3.l.google.com:19302']}],
        }

        connection = new RTCPeerConnection(config)
        connection.createDataChannel('')
        offer = await connection.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 })
        connection.setLocalDescription(offer)

        m = offer.sdp.match(new RegExp(/m=audio [^\s]+ [^\s]+ ([^\n|\r]+)/)) || []
        fp.webrtc.offer.audio.media_line = m[0]
        adescs = m[1]?.split(' ')

        adescs?.forEach(adesc => {
          fp.webrtc.offer.audio.rtpmap_lines.push(...(offer.sdp.match(RegExp(`a=(rtpmap|fmtp|rtcp-fb):${adesc} (.+)`, 'g'))))
        });

        m = offer.sdp.match(new RegExp(/m=video [^\s]+ [^\s]+ ([^\n|\r]+)/)) || []
        fp.webrtc.offer.video.media_line = m[0]
        vdescs = m[1]?.split(' ')

        vdescs?.forEach(vdesc => {
          fp.webrtc.offer.video.rtpmap_lines.push(...(offer.sdp.match(RegExp(`a=(rtpmap|fmtp|rtcp-fb):${vdesc} (.+)`, 'g'))))
        })

        ice_promise = get_ice_addresses(connection);

        ice_promise.then((addresses) => {
          fp.webrtc.addresses = addresses
          fp.webrtc.sdp = connection.localDescription.sdp.replace(/http:\/\//g, "http:_/").split(/\r\n/)
          fp.webrtc.connectionLineIpAddress = connection.localDescription.sdp.match(/c=IN\s.+\s/i)?.[0].trim()
          fp.webrtc.candidateIpAddress = connection.localDescription.sdp.match(/(udp|tcp)\s(\d|\w)+\s((\d|\w|(\.|\:))+)(?=\s)/i)?.[0]
          try { connection.close(); } catch(e){}
        });




        // ----

        await Promise.all([ice_promise]);

        return fp;
      }

      document.addEventListener('DOMContentLoaded', async () => {
        const fp = await collect_fp()
        console.log(JSON.stringify(fp, null, 2))

        const save_fp_btn = document.getElementById('save-fingerprint-btn')
        save_fp_btn.disabled = false
        save_fp_btn.addEventListener('click', () => {
          downloadAsFile({id: 777, "fingerprint": fp}, 'fingerprint')
        })

        var content = document.getElementById("content")

        const separator = "<tr><td style='border-top: 10px solid transparent' colspan=2></td></tr>"
        th = function(header) { content.innerHTML = header; return `${separator}<tr><th colspan=2>${header}</th></tr>` }

        str = "<table>"

        str += th("navigator");

        [ "webdriver", "appName", "appVersion", "deviceMemory", "hardwareConcurrency", "language", "languages",
          "maxTouchPoints", "onLine", "platform", "vendor", "userAgent", "userAgentData",
        ].forEach( key => {
          str += `<tr><td>${key}</td> <td>${JSON.stringify(navigator[key])}</td> </tr>`
        })

        str += th("webrtc")

        async function get_ice_addresses(connection) {
          return new Promise((resolve) => {
            addresses = []
            setTimeout(() => { return resolve(["timeout"]) }, 3000)

            connection.addEventListener("icecandidate", (event) => {
              if(event.candidate) {
                addresses.push(event.candidate.address)
              } else {
                resolve(addresses)
              }
            })
          })
        }

        config = {
          iceCandidatePoolSize: 1,
          iceServers: [{ urls: [ 'stun:stun4.l.google.com:19302', 'stun:stun3.l.google.com:19302']}],
        }

        connection = new RTCPeerConnection(config)
        connection.createDataChannel('')
        offer = await connection.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 })
        connection.setLocalDescription(offer)

        addresses = await get_ice_addresses(connection);
        connection.close()

        addresses.forEach( (address, i) => {
          str += `<tr><td>icecandidate[${i}] addr = </td> <td>${address}</td> </tr>`
        })

        connectionLineIpAddress = connection.localDescription.sdp.match(/c=IN\s.+\s/i)?.[0].trim()
        str += `<tr><td>sdp connection addrr = </td> <td>${connectionLineIpAddress}</td> </tr>`

        candidateIpAddress = connection.localDescription.sdp.match(/(udp|tcp)\s(\d|\w)+\s((\d|\w|(\.|\:))+)(?=\s)/i)?.[0]
        str += `<tr><td>sdp candidate addrr = </td> <td>${candidateIpAddress}</td> </tr>`

        str += th(`navigator.plugins: ${navigator.plugins.length}`)

        Array.from(navigator.plugins).forEach((p, i) => {
          str += `<tr><td>plugings[${i}]:</td>
                  <td>name: '${p.name}', filename: '${p.filename}', description: '${p.description}'`;

          Array.from(p).forEach((mt, j) => {
            str += `<br/>MimeType[${j}]: { type: '${mt.type}', description: '${mt.description}', suffixes: '${mt.suffixes}'`
          });

          str +=`</td></tr>`
        });

        str += th(`navigator.mimeTypes: ${navigator.mimeTypes.length}`)

        Array.from(navigator.mimeTypes).forEach((mt, i) => {
          str += `<tr><td>mimeTypes[${i}] </td>
                  <td>type: '${mt.type}', description: '${mt.description}', suffixes: '${mt.suffixes}',
                  enabledPlugin: '${mt.enabledPlugin && mt.enabledPlugin.name ? mt.enabledPlugin.name : null}'</td></tr>`
        });

        str += th(`speechSynthesis.getVoices(): ${speechSynthesis.getVoices().length}`)

        Array.from(speechSynthesis.getVoices()).forEach((voice, i) => {
          str += `<tr><td>speechSynthesis.getVoices[${i}] </td>
                  <td>name: '${voice.name}', voiceURI: '${voice.voiceURI}', lang: '${voice.lang}', localService: '${voice.localService}', default: '${voice.default}'</td></tr>`
        });

        str += th("misc")

        str += `<tr><td>window.chrome</td><td>${JSON.stringify(window.chrome)}</td></tr>`
        str += `<tr><td>chrome.runtime</td><td>${JSON.stringify(chrome.runtime)}</td></tr>`
        str += `<tr><td>chrome.app</td><td>${JSON.stringify(chrome.app)}</td></tr>`

        str += th("navigator.gpu.requestAdapter().info")

        adapter = (await navigator.gpu.requestAdapter());

        for(let key in adapter.info) {
          str += `<tr><td>info.${key} = </td> <td>${adapter.info[key]}</td> </tr>`
        };

        str += th(`navigator.gpu.requestAdapter().limits`);

        for(let key in adapter.limits) {
          str += `<tr><td>${key}: </td> <td>${adapter.limits[key]}</td> </tr>`
        };

        str += th(`navigator.gpu.requestAdapter().features: ${adapter.features.size}`)

        str += `<tr><td colspan=2>${JSON.stringify(Array.from(adapter.features))}</td></tr>`

        str += th("navigator.userAgentData.getHighEntropyValues()")

        var high_entr_fields = ['architecture', 'bitness', 'formFactors', 'fullVersionList', 'model', 'platformVersion', 'uaFullVersion', 'wow64' ]
        high_entr_values = await navigator.userAgentData.getHighEntropyValues(high_entr_fields);
        high_entr_fields.forEach(field => {
          str += `<tr><td>userAgentData.${field} = </td> <td>${JSON.stringify(high_entr_values[field])}</td></tr>`
        })

        str += th("navigator.getBattery()")

        battery = await navigator.getBattery();
        str += `<tr><td>charging: </td><td>${battery.charging}</td></tr>
                <tr><td>level: </td><td>${battery.level}</td></tr>
                <tr><td>chargingTime: </td><td>${battery.chargingTime}</td></tr>
                <tr><td>dischargingTime: </td><td>${battery.dischargingTime}</td></tr>`

        str += th("navigator.storage")

        function getTemporaryStorageUsage() {
          return new Promise((resolve, reject) => {
            navigator.webkitTemporaryStorage.queryUsageAndQuota((usage, quota) => {
              resolve({ usage: usage, quota: quota });
            })
          })
        }

        const { usage, quota } = await getTemporaryStorageUsage();
        str += `<tr><td>webkitTemporaryStorage.queryUsageAndQuota.quota: </td><td>${quota}</td></tr>
                <tr><td>webkitTemporaryStorage.queryUsageAndQuota.usage: </td><td>${usage}</td></tr>`

        str += `<tr><td>storage.estimate().quota: </td><td>${(await navigator.storage.estimate()).quota}</td></tr>
                <tr><td>storage.estimate().usage: </td><td>${(await navigator.storage.estimate()).usage}</td></tr>`

        str += th("navigator.bluetooth")

        str += `<tr><td>navigator.bluetooth: </td><td>${String(navigator.bluetooth)}</td></tr>`
        str += `<tr><td>navigator.bluetooth.getAvailability(): </td><td>${navigator.bluetooth ? (await navigator.bluetooth.getAvailability()) : false }</td></tr>`

        media_devices = await navigator.mediaDevices.enumerateDevices();
        str += th(`navigator.mediaDevices.enumerateDevices(): ${media_devices.length}`)

        media_devices.forEach((device, i) => {
          str += `<tr><td>mediaDevices[${i}] = </td><td>deviceId: '${device.deviceId}', groupId: '${device.groupId}', kind: '${device.kind}', label: '${device.label}'</td></tr>`
        });

        str += th("performance.memory")

        str += `<tr><td>performance.memory.jsHeapSizeLimit: </td><td>${performance.memory.jsHeapSizeLimit}</td></tr>
                <tr><td>performance.memory.totalJSHeapSize: </td><td>${performance.memory.totalJSHeapSize}</td></tr>
                <tr><td>performance.memory.usedJSHeapSize: </td><td>${performance.memory.usedJSHeapSize}</td></tr>`

        str += th(`window`)

        hasTouch = () => {
          try {
            return 'ontouchstart' in window && !!document.createEvent('TouchEvent')
          } catch (err) {
            return false
          }
        }

        str += `<tr><td> window.ontouchstart && !!document.createEvent('TouchEvent'): </td><td>${hasTouch()}</td></tr>`;

        str += separator;

        ["screenLeft", "screenTop", "innerWidth", "innerHeight", "outerWidth", "outerHeight", "devicePixelRatio"].forEach(key => {
          str += `<tr><td>window.${key}: </td><td>${window[key]}</td></tr>`
        });

        str += th("screen");

        ["availLeft", "availTop", "width", "height", "availWidth", "availHeight", "colorDepth", "pixelDepth", "isExtended"].forEach(key => {
          str += `<tr><td>screen.${key}: </td><td>${JSON.stringify(screen[key])}</td></tr>`
        });
        str += `<tr><td>screen.orientation.type: </td><td>${screen.orientation.type}</td></tr>`
        str += `<tr><td>screen.orientation.angle: </td><td>${screen.orientation.angle}</td></tr>`

        // str += th("navigator.geolocation");
        //
        // function getPosition(options) {
        //   return new Promise((resolve, reject) =>
        //     navigator.geolocation.getCurrentPosition(resolve, reject, options));}
        //
        // try {
        //   location = await getPosition({ maximumAge: 10000, timeout: 1000, enableHighAccuracy: true });
        //
        //   str += `
        //       <tr><td>latitude</td><td>${location.coords.latitude}</td></tr>
        //       <tr><td>longitude</td><td>${location.coords.longitude}</td></tr>
        //       <tr><td>altitude</td><td>${location.coords.altitude}</td></tr>
        //       <tr><td>accuracy</td><td>${location.coords.accuracy}</td></tr>
        //       <tr><td>altitudeAccuracy</td><td>${location.coords.altitudeAccuracy}</td></tr>
        //       <tr><td>heading</td><td>${location.coords.heading}</td></tr>
        //       <tr><td>speed</td><td>${location.coords.speed}</td></tr>`;
        // } catch (err) {
        //   console.error('Geolocation error:', err.code, err.message);
        //   str += `<tr><td>navigator.geolocation.getCurrentPosition()</td><td>error: ${err.code} ${err.message}</td></tr>`
        // }

        str += th("webgl");

        canvas = document.getElementById("canvas");
        gl1_context = canvas.getContext("webgl");

        renderer_info = gl1_context.getExtension("WEBGL_debug_renderer_info");

        str += `<tr><td>UNMASKED_VENDOR_WEBGL = </td><td>${gl1_context.getParameter(renderer_info.UNMASKED_VENDOR_WEBGL)}</td></tr>
                <tr><td>UNMASKED_RENDERER_WEBGL = </td><td>${gl1_context.getParameter(renderer_info.UNMASKED_RENDERER_WEBGL)}</td></tr>`

        str += th("webgl1 extensions");

        exts = gl1_context.getSupportedExtensions()
        str += `<tr><td> gl.getSupportedExtensions: ${exts.length} </td><td>${exts.join(', ')}</td></tr>`


        str += th("mime types");

        video = document.createElement('video');
        str += `<tr><td>video.canPlayType('video/not-supported') = </td><td>'${video.canPlayType('video/not-supported')}'</td></tr>
                <tr><td>video.canPlayType('video/h264') = </td><td>'${video.canPlayType('video/h264')}'</td></tr>
                <tr><td>video.canPlayType('video/webm') = </td><td>'${video.canPlayType('video/webm')}'</td></tr>`

        str += separator

        audio = new Audio();
        str += `<tr><td>audio.canPlayType('audio/not-supported') = </td><td>'${audio.canPlayType('audio/not-supported')}'</td></tr>
                <tr><td>audio.canPlayType('audio/ogg') = </td><td>'${audio.canPlayType('audio/ogg')}'</td></tr>
                <tr><td>audio.canPlayType('audio/m4a') = </td><td>'${audio.canPlayType('audio/m4a')}'</td></tr>`

        str += th("intl");

        str += `<tr><td>Intl.DateTimeFormat().resolvedOptions().timeZone: </td><td>${Intl.DateTimeFormat().resolvedOptions().timeZone}</td></tr>
                <tr><td>new Date().getTimezoneOffset() = </td><td>${(new Date().getTimezoneOffset())}</td></tr>
                <tr>
                  <td>(1).toLocaleString(undefined, {style: 'currency'}): </td>
                  <td>${(1).toLocaleString(undefined, { style: 'currency', currency: 'USD', currencyDisplay: 'name'})}</td>
                </tr>
                <tr>
                  <td>(1).toLocaleString(navigator.language, {style: 'currency'}): </td>
                  <td>${(1).toLocaleString(navigator.language, { style: 'currency', currency: 'USD', currencyDisplay: 'name'})}</td>
                </tr>
                <tr>
                  <td>(new Intl.Collator).resolvedOptions().locale: </td><td>${(new Intl.Collator).resolvedOptions().locale}</td>
                </tr>
                `
        str += th("canvas");

        str += "<tr><td><canvas id=canvas_1 width=200 height=50></canvas></td><td id=hash_1></td></tr>"
        str += "<tr><td><canvas id=canvas_2 width=200 height=50></canvas></td><td id=hash_2></td></tr>"

        str += "</table>"

        results = await getFontFingerprint([...fontCandidates, ...extendedFontList, ...nothing_fonts])

//        results = detectInstalledFonts([...fontCandidates, ...extendedFontList])

        console.log("Font Availability:", JSON.stringify(results));

        str += "<table border=1><tr><th>Font</th><th>Available</th></tr>";
        for (const font in results) {
          str +=
            `<tr>
              <td style="font-family:'${font}'">${font}</td>
              <td style="color:${results[font] ? 'green' : 'red'}"> ${results[font] ? "yes" : "no" }</td>
            </tr>`;
        }
        str += '</table>';
        content.innerHTML = str

        fingerprint1 = generateCanvasFingerprint(document.getElementById("canvas_1"));
        prev_fingerprint1_hash = localStorage.getItem("canvasFingerprint1");
        localStorage.setItem("canvasFingerprint1", fingerprint1.hash);
        // console.log('Canvas Fingerprint Hash:', fingerprint1.hash);

        fingerprint2 = generateCanvasFingerprint(document.getElementById("canvas_2"));
        prev_fingerprint2_hash = localStorage.getItem("canvasFingerprint2");
        localStorage.setItem("canvasFingerprint2", fingerprint2.hash);
        // console.log('Canvas Fingerprint Hash:', fingerprint2.hash);


        document.getElementById("hash_1").innerHTML = `current hash = ${fingerprint1.hash} prev hash = ${prev_fingerprint1_hash}`
        document.getElementById("hash_2").innerHTML = `current hash = ${fingerprint2.hash} prev hash = ${prev_fingerprint2_hash}`

      });

      function downloadAsFile(data, name) {
        const json = JSON.stringify(data, null, 2)
        const blob = new Blob([json], { type: 'application/json;charset=utf-8' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `${name}.json`
        document.body.appendChild(a)
        a.click()
        a.remove()
        URL.revokeObjectURL(url)
      }

       const fontCandidates = [
          'Arial', 'Arial Black', 'Arial Narrow', 'Arial Unicode MS',
          'Times New Roman', 'Times', 'Courier New', 'Courier',
          'Liberation Sans', 'Liberation Serif', 'Liberation Mono',
          'DejaVu Sans', 'DejaVu Serif', 'DejaVu Sans Mono',
          'Ubuntu', 'Ubuntu Mono', 'Ubuntu Condensed',
          'Noto Sans Avestan', 'Noto Sans Armenian', 'Noto Sans Cherokee',
          'Chandas', 'Lohit Devanagari', 'FreeMono',
          'Roboto',
            'Roboto Condensed',
            'Roboto Slab',
            'Noto Sans',
            'Noto Serif',
            'Noto Sans CJK JP',
            'Noto Sans CJK KR',
            'Noto Sans CJK SC',
            'Noto Sans Arabic',
            'Droid Sans',
            'Droid Sans Mono',
            'Droid Serif',
            'SamsungOne',
            'Samsung Sans',
            'MiLanProVF',
            'Oppo Sans',
            'LG Smart UI',
            'Helvetica',


  "Roboto Condensed Thin",
  "Roboto Condensed ExtraLight",
  "Roboto Condensed Light",
  "Roboto Condensed Regular",
  "Roboto Condensed Medium",
  "Roboto Condensed SemiBold",
  "Roboto Condensed Bold",
  "Roboto Condensed ExtraBold",
  "Roboto Condensed Black",
  "Roboto Condensed Thin Italic",
  "Roboto Condensed ExtraLight Italic",
  "Roboto Condensed Light Italic",
  "Roboto Condensed Italic",
  "Roboto Condensed Medium Italic",
  "Roboto Condensed SemiBold Italic",
  "Roboto Condensed Bold Italic",
  "Roboto Condensed ExtraBold Italic",
  "Roboto Condensed Black Italic",
  "Droid Sans Mono",
     ];
const extendedFontList = ["Abadi MT Condensed Light", "Academy Engraved LET", "ADOBE CASLON PRO", "Adobe Garamond", "ADOBE GARAMOND PRO", "Agency FB", "Aharoni", "Albertus Extra Bold", "Albertus Medium", "Algerian", "Amazone BT", "American Typewriter", "American Typewriter Condensed", "AmerType Md BT", "Andalus", "Angsana New", "AngsanaUPC", "Antique Olive", "Aparajita", "Apple Chancery", "Apple Color Emoji", "Apple SD Gothic Neo", "Arabic Typesetting", "ARCHER", "ARNO PRO", "Arrus BT", "Aurora Cn BT", "AvantGarde Bk BT", "AvantGarde Md BT", "AVENIR", "Ayuthaya", "Bandy", "Bangla Sangam MN", "Bank Gothic", "BankGothic Md BT", "Baskerville", "Baskerville Old Face", "Batang", "BatangChe", "Bauer Bodoni", "Bauhaus 93", "Bazooka", "Bell MT", "Bembo", "Benguiat Bk BT", "Berlin Sans FB", "Berlin Sans FB Demi", "Bernard MT Condensed", "BernhardFashion BT", "BernhardMod BT", "Big Caslon", "BinnerD", "Blackadder ITC", "BlairMdITC TT", "Bodoni 72", "Bodoni 72 Oldstyle", "Bodoni 72 Smallcaps", "Bodoni MT", "Bodoni MT Black", "Bodoni MT Condensed", "Bodoni MT Poster Compressed", "Bookshelf Symbol 7", "Boulder", "Bradley Hand", "Bradley Hand ITC", "Bremen Bd BT", "Britannic Bold", "Broadway", "Browallia New", "BrowalliaUPC", "Brush Script MT", "Californian FB", "Calisto MT", "Calligrapher", "Candara", "CaslonOpnface BT", "Castellar", "Centaur", "Cezanne", "CG Omega", "CG Times", "Chalkboard", "Chalkboard SE", "Chalkduster", "Charlesworth", "Charter Bd BT", "Charter BT", "Chaucer", "ChelthmITC Bk BT", "Chiller", "Clarendon", "Clarendon Condensed", "CloisterBlack BT", "Cochin", "Colonna MT", "Constantia", "Cooper Black", "Copperplate", "Copperplate Gothic", "Copperplate Gothic Bold", "Copperplate Gothic Light", "CopperplGoth Bd BT", "Corbel", "Cordia New", "CordiaUPC", "Cornerstone", "Coronet", "Cuckoo", "Curlz MT", "DaunPenh", "Dauphin", "David", "DB LCD Temp", "DELICIOUS", "Denmark", "DFKai-SB", "Didot", "DilleniaUPC", "DIN", "DokChampa", "Dotum", "DotumChe", "Ebrima", "Edwardian Script ITC", "Elephant", "English 111 Vivace BT", "Engravers MT", "EngraversGothic BT", "Eras Bold ITC", "Eras Demi ITC", "Eras Light ITC", "Eras Medium ITC", "EucrosiaUPC", "Euphemia", "Euphemia UCAS", "EUROSTILE", "Exotc350 Bd BT", "FangSong", "Felix Titling", "Fixedsys", "FONTIN", "Footlight MT Light", "Forte", "FrankRuehl", "Fransiscan", "Freefrm721 Blk BT", "FreesiaUPC", "Freestyle Script", "French Script MT", "FrnkGothITC Bk BT", "Fruitger", "FRUTIGER", "Futura", "Futura Bk BT", "Futura Lt BT", "Futura Md BT", "Futura ZBlk BT", "FuturaBlack BT", "Gabriola", "Galliard BT", "Gautami", "Geeza Pro", "Geometr231 BT", "Geometr231 Hv BT", "Geometr231 Lt BT", "GeoSlab 703 Lt BT", "GeoSlab 703 XBd BT", "Gigi", "Gill Sans", "Gill Sans MT", "Gill Sans MT Condensed", "Gill Sans MT Ext Condensed Bold", "Gill Sans Ultra Bold", "Gill Sans Ultra Bold Condensed", "Gisha", "Gloucester MT Extra Condensed", "GOTHAM", "GOTHAM BOLD", "Goudy Old Style", "Goudy Stout", "GoudyHandtooled BT", "GoudyOLSt BT", "Gujarati Sangam MN", "Gulim", "GulimChe", "Gungsuh", "GungsuhChe", "Gurmukhi MN", "Haettenschweiler", "Harlow Solid Italic", "Harrington", "Heather", "Heiti SC", "Heiti TC", "HELV", "Herald", "High Tower Text", "Hiragino Kaku Gothic ProN", "Hiragino Mincho ProN", "Hoefler Text", "Humanst 521 Cn BT", "Humanst521 BT", "Humanst521 Lt BT", "Imprint MT Shadow", "Incised901 Bd BT", "Incised901 BT", "Incised901 Lt BT", "INCONSOLATA", "Informal Roman", "Informal011 BT", "INTERSTATE", "IrisUPC", "Iskoola Pota", "JasmineUPC", "Jazz LET", "Jenson", "Jester", "Jokerman", "Juice ITC", "Kabel Bk BT", "Kabel Ult BT", "Kailasa", "KaiTi", "Kalinga", "Kannada Sangam MN", "Kartika", "Kaufmann Bd BT", "Kaufmann BT", "Khmer UI", "KodchiangUPC", "Kokila", "Korinna BT", "Kristen ITC", "Krungthep", "Kunstler Script", "Lao UI", "Latha", "Leelawadee", "Letter Gothic", "Levenim MT", "LilyUPC", "Lithograph", "Lithograph Light", "Long Island", "Lydian BT", "Magneto", "Maiandra GD", "Malayalam Sangam MN", "Malgun Gothic", "Mangal", "Marigold", "Marion", "Marker Felt", "Market", "Marlett", "Matisse ITC", "Matura MT Script Capitals", "Meiryo", "Meiryo UI", "Microsoft Himalaya", "Microsoft JhengHei", "Microsoft New Tai Lue", "Microsoft PhagsPa", "Microsoft Tai Le", "Microsoft Uighur", "Microsoft YaHei", "Microsoft Yi Baiti", "MingLiU", "MingLiU_HKSCS", "MingLiU_HKSCS-ExtB", "MingLiU-ExtB", "Minion", "Minion Pro", "Miriam", "Miriam Fixed", "Mistral", "Modern", "Modern No. 20", "Mona Lisa Solid ITC TT", "Mongolian Baiti", "MONO", "MoolBoran", "Mrs Eaves", "MS LineDraw", "MS Mincho", "MS PMincho", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MUSEO", "MV Boli", "Nadeem", "Narkisim", "NEVIS", "News Gothic", "News GothicMT", "NewsGoth BT", "Niagara Engraved", "Niagara Solid", "Noteworthy", "NSimSun", "Nyala", "OCR A Extended", "Old Century", "Old English Text MT", "Onyx", "Onyx BT", "OPTIMA", "Oriya Sangam MN", "OSAKA", "OzHandicraft BT", "Palace Script MT", "Papyrus", "Parchment", "Party LET", "Pegasus", "Perpetua", "Perpetua Titling MT", "PetitaBold", "Pickwick", "Plantagenet Cherokee", "Playbill", "PMingLiU", "PMingLiU-ExtB", "Poor Richard", "Poster", "PosterBodoni BT", "PRINCETOWN LET", "Pristina", "PTBarnum BT", "Pythagoras", "Raavi", "Rage Italic", "Ravie", "Ribbon131 Bd BT", "Rockwell", "Rockwell Condensed",
"Rockwell Extra Bold", "Rod", "Roman", "Sakkal Majalla", "Santa Fe LET", "Savoye LET", "Sceptre", "Script", "Script MT Bold", "SCRIPTINA", "Serifa", "Serifa BT", "Serifa Th BT", "ShelleyVolante BT", "Sherwood", "Shonar Bangla", "Showcard Gothic", "Shruti", "Signboard", "SILKSCREEN", "SimHei", "Simplified Arabic", "Simplified Arabic Fixed", "SimSun", "SimSun-ExtB", "Sinhala Sangam MN", "Sketch Rockwell", "Skia", "Small Fonts", "Snap ITC", "Snell Roundhand", "Socket", "Souvenir Lt BT", "Staccato222 BT", "Steamer", "Stencil", "Storybook", "Styllo", "Subway", "Swis721 BlkEx BT", "Swiss911 XCm BT", "Sylfaen", "Synchro LET", "System", "Tamil Sangam MN", "Technical", "Teletype", "Telugu Sangam MN", "Tempus Sans ITC", "Terminal", "Thonburi", "Traditional Arabic", "Trajan", "TRAJAN PRO", "Tristan", "Tubular", "Tunga", "Tw Cen MT", "Tw Cen MT Condensed", "Tw Cen MT Condensed Extra Bold", "TypoUpright BT", "Unicorn", "Univers", "Univers CE 55 Medium", "Univers Condensed", "Utsaah", "Vagabond", "Vani", "Vijaya", "Viner Hand ITC", "VisualUI", "Vivaldi", "Vladimir Script", "Vrinda", "Westminster", "WHITNEY", "Wide Latin", "ZapfEllipt BT", "ZapfHumnst BT", "ZapfHumnst Dm BT", "Zapfino", "Zurich BlkEx BT", "Zurich Ex BT", "ZWAdobeF"];


  nothing_fonts = [
"sans-serif-thin",
  "sans-serif-light",
  "sans-serif-medium",
  "sans-serif-black",
  "arial",
  "helvetica",
  "tahoma",
  "verdana",
  "sans-serif-condensed-light",
  "sans-serif-condensed-medium",
  "serif-bold",
  "times",
  "times new roman",
  "palatino",
  "georgia",
  "baskerville",
  "goudy",
  "fantasy",
  "ITC Stone Serif",
  "sans-serif-monospace",
  "monaco",
  "courier",
  "courier new",
  "source-sans-pro-semi-bold",
  "sans-serif",
  "sans-serif-condensed",
  "serif",
  "monospace",
  "serif-monospace",
  "casual",
  "cursive",
  "sans-serif-smallcaps",
  "source-sans-pro",
  "roboto-flex",
  "AndroidClock",
  "AndroidClock Regular",
  "Carrois Gothic SC",
  "Carrois Gothic SC Regular",
  "Coming Soon",
  "Coming Soon Regular",
  "Cutive Mono",
  "Cutive Mono Regular",
  "Dancing Script",
  "Dancing Script Regular",
  "Dancing Script Medium",
  "Dancing Script SemiBold",
  "Dancing Script Bold",
  "Roboto",
  "Roboto Thin",
  "Roboto ExtraLight",
  "Roboto Light",
  "Roboto Medium",
  "Roboto SemiBold",
  "Roboto Bold",
  "Roboto ExtraBold",
  "Roboto Black",
  "Roboto Thin Italic",
  "Roboto ExtraLight Italic",
  "Roboto Light Italic",
  "Roboto Italic",
  "Roboto Medium Italic",
  "Roboto SemiBold Italic",
  "Roboto Bold Italic",
  "Roboto ExtraBold Italic",
  "Roboto Black Italic",
  "Roboto Condensed Thin",
  "Roboto Condensed ExtraLight",
  "Roboto Condensed Light",
  "Roboto Condensed Regular",
  "Roboto Condensed Medium",
  "Roboto Condensed SemiBold",
  "Roboto Condensed Bold",
  "Roboto Condensed ExtraBold",
  "Roboto Condensed Black",
  "Roboto Condensed Thin Italic",
  "Roboto Condensed ExtraLight Italic",
  "Roboto Condensed Light Italic",
  "Roboto Condensed Italic",
  "Roboto Condensed Medium Italic",
  "Roboto Condensed SemiBold Italic",
  "Roboto Condensed Bold Italic",
  "Roboto Condensed ExtraBold Italic",
  "Roboto Condensed Black Italic",
  "Droid Sans Mono",
  "Inter",
  "Inter Light",
  "Inter Medium",
  "Inter Variable",
  "Inter Variable Thin",
  "Inter Variable ExtraLight",
  "Inter Variable Light",
  "Inter Variable Medium",
  "Inter Variable SemiBold",
  "Inter Variable Bold",
  "Inter Variable ExtraBold",
  "Inter Variable Black",
  "Inter Variable Italic",
  "Inter Variable Thin Italic",
  "Inter Variable ExtraLight Italic",
  "Inter Variable Light Italic",
  "Inter Variable Medium Italic",
  "Inter Variable SemiBold Italic",
  "Inter Variable Bold Italic",
  "Inter Variable ExtraBold Italic",
  "Inter Variable Black Italic",
  "Lettera Mono LL",
  "Lettera Mono LL Italic",
  "Lettera Mono LL Light",
  "Lettera Mono LL Light Italic",
  "Lettera Mono LL Medium",
  "Lettera Mono LL Medium Italic",
  "Ndot",
  "Ndot 55",
  "Ndot 57",
  "NType 82",
  "NType 82 Headline",
  "NType 82 Regular",
  "Ndot 57 Aligned",
  "Ndot77JPExtended",
  "乤潴㜷䩐䕸瑥湤敤",
  "Ndot 77 JP Extended Regular",
  "Noto Color Emoji",
  "Noto Color Emoji Flags",
  "Noto Naskh Arabic",
  "Noto Naskh Arabic Bold",
  "Noto Naskh Arabic UI",
  "Noto Naskh Arabic UI Bold",
  "Noto Sans Adlam",
  "Noto Sans Adlam Regular",
  "Noto Sans Adlam Bold",
  "Noto Sans Ahom",
  "Noto Sans Ahom Regular",
  "Noto Sans Anatolian Hieroglyphs",
  "Noto Sans AnatoHiero",
  "Noto Sans Anatolian Hieroglyphs Regular",
  "Noto Sans Armenian",
  "Noto Sans Armenian Regular",
  "Noto Sans Armenian Medium",
  "Noto Sans Armenian SemiBold",
  "Noto Sans Armenian Bold",
  "Noto Sans Avestan",
  "Noto Sans Balinese",
  "Noto Sans Bamum",
  "Noto Sans Bassa Vah",
  "Noto Sans Bassa Vah Regular",
  "Noto Sans Batak",
  "Noto Sans Bengali",
  "Noto Sans Bengali Regular",
  "Noto Sans Bengali Medium",
  "Noto Sans Bengali SemiBold",
  "Noto Sans Bengali Bold",
  "Noto Sans Bengali UI",
  "Noto Sans Bengali UI Regular",
  "Noto Sans Bengali UI Medium",
  "Noto Sans Bengali UI SemiBold",
  "Noto Sans Bengali UI Bold",
  "Noto Sans Bhaiksuki",
  "Noto Sans Bhaiksuki Regular",
  "Noto Sans Brahmi",
  "Noto Sans Buginese",
  "Noto Sans Buhid",
  "Noto Sans CJK JP",
  "Noto Sans CJK JP Regular",
//  "Noto Sans CJK JP Medium",
//  "Noto Sans CJK JP SemiBold",
//  "Noto Sans CJK JP Bold",
//  "Noto Sans CJK JP ExtraBold",
//  "Noto Sans CJK JP Black",
  "Noto Sans CJK KR",
  "Noto Sans CJK KR Regular",
//  "Noto Sans CJK KR Medium",
//  "Noto Sans CJK KR SemiBold",
//  "Noto Sans CJK KR Bold",
//  "Noto Sans CJK KR ExtraBold",
//  "Noto Sans CJK KR Black",
  "Noto Sans CJK SC",
  "Noto Sans CJK SC Regular",
//  "Noto Sans CJK SC Medium",
//  "Noto Sans CJK SC SemiBold",
//  "Noto Sans CJK SC Bold",
//  "Noto Sans CJK SC ExtraBold",
//  "Noto Sans CJK SC Black",
  "Noto Sans CJK TC",
  "Noto Sans CJK TC Regular",
//  "Noto Sans CJK TC Medium",
//  "Noto Sans CJK TC SemiBold",
//  "Noto Sans CJK TC Bold",
//  "Noto Sans CJK TC ExtraBold",
//  "Noto Sans CJK TC Black",
  "Noto Sans CJK HK",
  "Noto Sans CJK HK Regular",
//  "Noto Sans CJK HK Medium",
//  "Noto Sans CJK HK SemiBold",
//  "Noto Sans CJK HK Bold",
//  "Noto Sans CJK HK ExtraBold",
//  "Noto Sans CJK HK Black",
  "Noto Sans Canadian Aboriginal",
  "Noto Sans CanAborig",
  "Noto Sans Canadian Aboriginal Regular",
  "Noto Sans Carian",
  "Noto Sans Chakma",
  "Noto Sans Chakma Regular",
  "Noto Sans Cham",
  "Noto Sans Cham Bold",
  "Noto Sans Cherokee",
  "Noto Sans Cherokee Regular",
  "Noto Sans Coptic",
  "Noto Sans Cuneiform",
  "Noto Sans Cypriot",
  "Noto Sans Deseret",
  "Noto Sans Devanagari",
  "Noto Sans Devanagari Regular",
  "Noto Sans Devanagari Medium",
  "Noto Sans Devanagari SemiBold",
  "Noto Sans Devanagari Bold",
  "Noto Sans Devanagari UI",
  "Noto Sans Devanagari UI Regular",
  "Noto Sans Devanagari UI Medium",
  "Noto Sans Devanagari UI SemiBold",
  "Noto Sans Devanagari UI Bold",
  "Noto Sans Egyptian Hieroglyphs",
  "Noto Sans Elbasan",
  "Noto Sans Elbasan Regular",
  "Noto Sans Ethiopic",
  "Noto Sans Ethiopic Regular",
  "Noto Sans Ethiopic Medium",
  "Noto Sans Ethiopic SemiBold",
  "Noto Sans Ethiopic Bold",
  "Noto Sans Georgian",
  "Noto Sans Georgian Regular",
  "Noto Sans Georgian Medium",
  "Noto Sans Georgian SemiBold",
  "Noto Sans Georgian Bold",
  "Noto Sans Glagolitic",
  "Noto Sans Gothic",
  "Noto Sans Grantha",
  "Noto Sans Grantha Regular",
  "Noto Sans Gujarati",
  "Noto Sans Gujarati Bold",
  "Noto Sans Gujarati UI",
  "Noto Sans Gujarati UI Bold",
  "Noto Sans Gunjala Gondi",
  "Noto Sans Gunjala Gondi Regular",
  "Noto Sans Gurmukhi",
  "Noto Sans Gurmukhi Regular",
  "Noto Sans Gurmukhi Medium",
  "Noto Sans Gurmukhi SemiBold",
  "Noto Sans Gurmukhi Bold",
  "Noto Sans Gurmukhi UI",
  "Noto Sans Gurmukhi UI Regular",
  "Noto Sans Gurmukhi UI Medium",
  "Noto Sans Gurmukhi UI SemiBold",
  "Noto Sans Gurmukhi UI Bold",
  "Noto Sans Hanifi Rohingya",
  "Noto Sans HanifiRohg",
  "Noto Sans Hanifi Rohingya Regular",
  "Noto Sans Hanunoo",
  "Noto Sans Hatran",
  "Noto Sans Hatran Regular",
  "Noto Sans Hebrew",
  "Noto Sans Hebrew Bold",
  "Noto Sans Imperial Aramaic",
  "Noto Sans Inscriptional Pahlavi",
  "Noto Sans Inscriptional Parthian",
  "Noto Sans Javanese",
  "Noto Sans Javanese Regular",
  "Noto Sans Kaithi",
  "Noto Sans Kannada",
  "Noto Sans Kannada Regular",
  "Noto Sans Kannada Medium",
  "Noto Sans Kannada SemiBold",
  "Noto Sans Kannada Bold",
  "Noto Sans Kannada UI",
  "Noto Sans KannadaUI Regular",
  "Noto Sans Kannada UI Medium",
  "Noto Sans Kannada UI SemiBold",
  "Noto Sans Kannada UI Bold",
  "Noto Sans Kayah Li",
  "Noto Sans Kharoshthi",
  "Noto Sans Khmer",
  "Noto Sans Khmer Thin",
  "Noto Sans Khmer ExtraLight",
  "Noto Sans Khmer Light",
  "Noto Sans Khmer Medium",
  "Noto Sans Khmer SemiBold",
  "Noto Sans Khmer Bold",
  "Noto Sans Khmer ExtraBold",
  "Noto Sans Khmer Black",
  "Noto Sans Khmer Condensed Thin",
  "Noto Sans Khmer Condensed ExtraLight",
  "Noto Sans Khmer Condensed Light",
  "Noto Sans Khmer Condensed",
  "Noto Sans Khmer Condensed Medium",
  "Noto Sans Khmer Condensed SemiBold",
  "Noto Sans Khmer Condensed Bold",
  "Noto Sans Khmer Condensed ExtraBold",
  "Noto Sans Khmer Condensed Black",
  "Noto Sans Khmer SemiCondensed Thin",
  "Noto Sans Khmer SemiCondensed ExtraLight",
  "Noto Sans Khmer SemiCondensed Light",
  "Noto Sans Khmer SemiCondensed",
  "Noto Sans Khmer SemiCondensed Medium",
  "Noto Sans Khmer SemiCondensed SemiBold",
  "Noto Sans Khmer SemiCondensed Bold",
  "Noto Sans Khmer SemiCondensed ExtraBold",
  "Noto Sans Khmer SemiCondensed Black",
  "Noto Sans Khmer ExtraCondensed Thin",
  "Noto Sans Khmer ExtraCondensed ExtraLight",
  "Noto Sans Khmer ExtraCondensed Light",
  "Noto Sans Khmer ExtraCondensed",
  "Noto Sans Khmer ExtraCondensed Medium",
  "Noto Sans Khmer ExtraCondensed SemiBold",
  "Noto Sans Khmer ExtraCondensed Bold",
  "Noto Sans Khmer ExtraCondensed ExtraBold",
  "Noto Sans Khmer ExtraCondensed Black",
  "Noto Sans Khmer UI",
  "Noto Sans Khmer UI Bold",
  "Noto Sans Khojki",
  "Noto Sans Khojki Regular",
  "Noto Sans Lao",
  "Noto Sans Lao Bold",
  "Noto Sans Lao Regular",
  "Noto Sans Lao UI",
  "Noto Sans Lao UI Bold",
  "Noto Sans Lepcha",
  "Noto Sans Limbu",
  "Noto Sans Linear A",
  "Noto Sans Linear A Regular",
  "Noto Sans Linear B",
  "Noto Sans Lisu",
  "Noto Sans Lycian",
  "Noto Sans Lydian",
  "Noto Sans Malayalam",
  "Noto Sans Malayalam Regular",
  "Noto Sans Malayalam Medium",
  "Noto Sans Malayalam SemiBold",
  "Noto Sans Malayalam Bold",
  "Noto Sans Malayalam UI",
  "Noto Sans MalayalamUI Regular",
  "Noto Sans Malayalam UI Medium",
  "Noto Sans Malayalam UI SemiBold",
  "Noto Sans Malayalam UI Bold",
  "Noto Sans Mandaic",
  "Noto Sans Manichaean",
  "Noto Sans Manichaean Regular",
  "Noto Sans Marchen",
  "Noto Sans Marchen Regular",
  "Noto Sans Masaram Gondi",
  "Noto Sans Masaram Gondi Regular",
  "Noto Sans Medefaidrin",
  "Noto Sans Medefaidrin Regular",
  "Noto Sans Medefaidrin Medium",
  "Noto Sans Medefaidrin SemiBold",
  "Noto Sans Medefaidrin Bold",
  "Noto Sans Meetei Mayek",
  "Noto Sans Meroitic",
  "Noto Sans Meroitic Regular",
  "Noto Sans Miao",
  "Noto Sans Miao Regular",
  "Noto Sans Modi",
  "Noto Sans Modi Regular",
  "Noto Sans Mongolian",
  "Noto Sans Mro",
  "Noto Sans Mro Regular",
  "Noto Sans Multani",
  "Noto Sans Multani Regular",
  "Noto Sans Myanmar",
  "Noto Sans Myanmar Bold",
  "Noto Sans Myanmar Med",
  "Noto Sans Myanmar Medium",
  "Noto Sans Myanmar Regular",
  "Noto Sans Myanmar UI",
  "Noto Sans Myanmar UI Bold",
  "Noto Sans Myanmar UI Medium",
  "Noto Sans Myanmar UI Regular",
  "Noto Sans NKo",
  "Noto Sans Nabataean",
  "Noto Sans Nabataean Regular",
  "Noto Sans New Tai Lue",
  "Noto Sans Newa",
  "Noto Sans Newa Regular",
  "Noto Sans Ogham",
  "Noto Sans Ol Chiki",
  "Noto Sans Old Italic",
  "Noto Sans Old North Arabian",
  "Noto Sans OldNorArab",
  "Noto Sans Old North Arabian Regular",
  "Noto Sans Old Permic",
  "Noto Sans Old Permic Regular",
  "Noto Sans Old Persian",
  "Noto Sans Old South Arabian",
  "Noto Sans Old Turkic",
  "Noto Sans Oriya",
  "Noto Sans Oriya Bold",
  "Noto Sans Oriya UI",
  "Noto Sans Oriya UI Bold",
  "Noto Sans Osage",
  "Noto Sans Osage Regular",
  "Noto Sans Osmanya",
  "Noto Sans Pahawh Hmong",
  "Noto Sans Pahawh Hmong Regular",
  "Noto Sans Palmyrene",
  "Noto Sans Palmyrene Regular",
  "Noto Sans Pau Cin Hau",
  "Noto Sans Pau Cin Hau Regular",
  "Noto Sans Phags Pa",
  "Noto Sans Phoenician",
  "Noto Sans Rejang",
  "Noto Sans Runic",
  "Noto Sans Samaritan",
  "Noto Sans Saurashtra",
  "Noto Sans Sharada",
  "Noto Sans Sharada Regular",
  "Noto Sans Shavian",
  "Noto Sans Sinhala",
  "Noto Sans Sinhala Regular",
  "Noto Sans Sinhala Medium",
  "Noto Sans Sinhala SemiBold",
  "Noto Sans Sinhala Bold",
  "Noto Sans Sinhala UI",
  "Noto Sans Sinhala UI Regular",
  "Noto Sans Sinhala UI Medium",
  "Noto Sans Sinhala UI SemiBold",
  "Noto Sans Sinhala UI Bold",
  "Noto Sans Sora Sompeng",
  "Noto Sans SoraSomp",
  "Noto Sans Sora Sompeng Regular",
  "Noto Sans Soyombo",
  "Noto Sans Soyombo Regular",
  "Noto Sans Sundanese",
  "Noto Sans Syloti Nagri",
  "Noto Sans Symbols",
  "Noto Sans Syriac Eastern",
  "Noto Sans Syriac Estrangela",
  "Noto Sans Syriac Western",
  "Noto Sans Tagalog",
  "Noto Sans Tagbanwa",
  "Noto Sans Tai Le",
  "Noto Sans Tai Tham",
  "Noto Sans Tai Viet",
  "Noto Sans Takri",
  "Noto Sans Takri Regular",
  "Noto Sans Tamil",
  "Noto Sans Tamil Regular",
  "Noto Sans Tamil Medium",
  "Noto Sans Tamil SemiBold",
  "Noto Sans Tamil Bold",
  "Noto Sans Tamil UI",
  "Noto Sans TamilUI Regular",
  "Noto Sans Tamil UI Medium",
  "Noto Sans Tamil UI SemiBold",
  "Noto Sans Tamil UI Bold",
  "Noto Sans Telugu",
  "Noto Sans Telugu Regular",
  "Noto Sans Telugu Medium",
  "Noto Sans Telugu SemiBold",
  "Noto Sans Telugu Bold",
  "Noto Sans Telugu UI",
  "Noto Sans TeluguUI Regular",
  "Noto Sans Telugu UI Medium",
  "Noto Sans Telugu UI SemiBold",
  "Noto Sans Telugu UI Bold",
  "Noto Sans Thaana",
  "Noto Sans Thaana Bold",
  "Noto Sans Thai",
  "Noto Sans Thai Bold",
  "Noto Sans Thai UI",
  "Noto Sans Thai UI Bold",
  "Noto Sans Tifinagh",
  "Noto Sans Tifinagh Regular",
  "Noto Sans Ugaritic",
  "Noto Sans Vai",
  "Noto Sans Wancho",
  "Noto Sans Wancho Regular",
  "Noto Sans Warang Citi",
  "Noto Sans Warang Citi Regular",
  "Noto Sans Yi",
  "Noto Serif",
  "Noto Serif Bold",
  "Noto Serif Bold Italic",
  "Noto Serif Italic",
  "Noto Serif Armenian",
  "Noto Serif Armenian Regular",
  "Noto Serif Armenian Medium",
  "Noto Serif Armenian SemiBold",
  "Noto Serif Armenian Bold",
  "Noto Serif Bengali",
  "Noto Serif Bengali Regular",
  "Noto Serif Bengali Medium",
  "Noto Serif Bengali SemiBold",
  "Noto Serif Bengali Bold",
  "Noto Serif CJK JP",
  "Noto Serif CJK KR",
  "Noto Serif CJK SC",
  "Noto Serif CJK TC",
  "Noto Serif CJK HK",
  "Noto Serif Devanagari",
  "Noto Serif Devanagari Regular",
  "Noto Serif Devanagari Medium",
  "Noto Serif Devanagari SemiBold",
  "Noto Serif Devanagari Bold",
  "Noto Serif Dogra",
  "Noto Serif Dogra Regular",
  "Noto Serif Ethiopic",
  "Noto Serif Ethiopic Regular",
  "Noto Serif Ethiopic Medium",
  "Noto Serif Ethiopic SemiBold",
  "Noto Serif Ethiopic Bold",
  "Noto Serif Georgian",
  "Noto Serif Georgian Regular",
  "Noto Serif Georgian Medium",
  "Noto Serif Georgian SemiBold",
  "Noto Serif Georgian Bold",
  "Noto Serif Gujarati",
  "Noto Serif Gujarati Regular",
  "Noto Serif Gujarati Medium",
  "Noto Serif Gujarati SemiBold",
  "Noto Serif Gujarati Bold",
  "Noto Serif Gurmukhi",
  "Noto Serif Gurmukhi Regular",
  "Noto Serif Gurmukhi Medium",
  "Noto Serif Gurmukhi SemiBold",
  "Noto Serif Gurmukhi Bold",
  "Noto Serif Hebrew",
  "Noto Serif Hebrew Bold",
  "Noto Serif Hebrew Regular",
  "Noto Serif Hentaigana",
  "Noto Serif Hentaigana ExtraLight",
  "Noto Serif Hentaigana Light",
  "Noto Serif Hentaigana Regular",
  "Noto Serif Hentaigana Medium",
  "Noto Serif Hentaigana SemiBold",
  "Noto Serif Hentaigana Bold",
  "Noto Serif Hentaigana ExtraBold",
  "Noto Serif Hentaigana Black",
  "Noto Serif Kannada",
  "Noto Serif Kannada Regular",
  "Noto Serif Kannada Medium",
  "Noto Serif Kannada SemiBold",
  "Noto Serif Kannada Bold",
  "Noto Serif Khmer",
  "Noto Serif Khmer Bold",
  "Noto Serif Khmer Regular",
  "Noto Serif Lao",
  "Noto Serif Lao Bold",
  "Noto Serif Lao Regular",
  "Noto Serif Malayalam",
  "Noto Serif Malayalam Regular",
  "Noto Serif Malayalam Medium",
  "Noto Serif Malayalam SemiBold",
  "Noto Serif Malayalam Bold",
  "Noto Serif Myanmar",
  "Noto Serif Myanmar Bold",
  "Noto Serif Myanmar Regular",
  "Noto Serif Nyiakeng Puachue Hmong",
  "Noto Serif Hmong Nyiakeng",
  "Noto Serif Nyiakeng Puachue Hmong Regular",
  "Noto Serif Nyiakeng Puachue Hmong Medium",
  "Noto Serif Nyiakeng Puachue Hmong SemiBold",
  "Noto Serif Nyiakeng Puachue Hmong Bold",
  "Noto Serif Sinhala",
  "Noto Serif Sinhala Regular",
  "Noto Serif Sinhala Medium",
  "Noto Serif Sinhala SemiBold",
  "Noto Serif Sinhala Bold",
  "Noto Serif Tamil",
  "Noto Serif Tamil Regular",
  "Noto Serif Tamil Medium",
  "Noto Serif Tamil SemiBold",
  "Noto Serif Tamil Bold",
  "Noto Serif Telugu",
  "Noto Serif Telugu Regular",
  "Noto Serif Telugu Medium",
  "Noto Serif Telugu SemiBold",
  "Noto Serif Telugu Bold",
  "Noto Serif Thai",
  "Noto Serif Thai Bold",
  "Noto Serif Thai Regular",
  "Noto Serif Tibetan",
  "Noto Serif Tibetan Regular",
  "Noto Serif Tibetan Medium",
  "Noto Serif Tibetan SemiBold",
  "Noto Serif Tibetan Bold",
  "Noto Serif Yezidi",
  "Noto Serif Yezidi Regular",
  "Noto Serif Yezidi Medium",
  "Noto Serif Yezidi SemiBold",
  "Noto Serif Yezidi Bold",
  "Roboto Flex",
  "Roboto Flex Regular",
  "Roboto Flex Thin",
  "Roboto Flex ExtraLight",
  "Roboto Flex Light",
  "Roboto Flex Medium",
  "Roboto Flex SemiBold",
  "Roboto Flex Bold",
  "Roboto Flex ExtraBold",
  "Roboto Flex Black",
  "Roboto Flex ExtraBlack",
  "Roboto Flex Thin Italic",
  "Roboto Flex ExtraLight Italic",
  "Roboto Flex Light Italic",
  "Roboto Flex Italic",
  "Roboto Flex Medium Italic",
  "Roboto Flex SemiBold Italic",
  "Roboto Flex Bold Italic",
  "Roboto Flex ExtraBold Italic",
  "Roboto Flex Black Italic",
  "Roboto Flex ExtraBlack Italic",
  "RobotoStatic",
  "Source Sans Pro",
  "Source Sans Pro Bold",
  "Source Sans Pro Bold Italic",
  "Source Sans Pro Italic",
  "Source Sans Pro Regular",
  "Source Sans Pro SemiBold",
  "Source Sans Pro SemiBold Italic"

    ];


      async function getFontFingerprint(fontList) {

        const results = {};
        const testString = "mmMwWLliI0O&1";
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        for (const font of fontList) {
          try {
            const fontFace = new FontFace(font, `local("${font}")`);
            await fontFace.load();
            results[font] = fontFace.status === 'loaded';
          } catch {
            results[font] = false;
          }
        }

        // ctx.font = '16px sans-serif';
        // const baseWidth = ctx.measureText(testString).width;
        //
        // for (const font in results) {
        //   if (!results[font]) {
        //     ctx.font = `16px "${font}", sans-serif`;
        //     const testWidth = ctx.measureText(testString).width;
        //     results[font] |= Math.abs(testWidth - baseWidth) > 2;
        //   }
        // }

        return results;
      }


function detectInstalledFonts(fontNames) {
  const testString = 'mmmmmmmmmwwwwwww0123456789абвгдABCD'; // чтобы ширина была чувствительной
  const testSize = '72px'; // побольше — разница заметнее
  const body = document.body || document.documentElement;

  const span = document.createElement('span');
  span.textContent = testString;
  span.style.fontSize = testSize;
  span.style.position = 'absolute';
  span.style.left = '-9999px';
  span.style.top = '-9999px';
  span.style.whiteSpace = 'nowrap';

  const baseMetrics = {};
  body.appendChild(span);

  // Сначала меряем базовые шрифты
  const BASE_FONTS = ['monospace', 'sans-serif', 'serif'];

  BASE_FONTS.forEach(base => {
    span.style.fontFamily = base;
    const rect = span.getBoundingClientRect();
    baseMetrics[base] = { width: rect.width, height: rect.height };
  });

  const result = {};

  fontNames.forEach(name => {
    let isInstalled = false;

    for (const base of BASE_FONTS) {
      span.style.fontFamily = `"${name}",${base}`;
      const rect = span.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const baseRect = baseMetrics[base];
      // Если размеры отличаются от базового — значит, подставился настоящий шрифт
      if (w !== baseRect.width || h !== baseRect.height) {
        isInstalled = true;
        break;
      }
    }

    result[name] = isInstalled;
  });

  span.remove();
  return result;
}

      function generateCanvasFingerprint(canvas) {
        const ctx = canvas.getContext('2d');

        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#069';
        ctx.fillText('Canvas Fingerprint: @' + new Date().toISOString(), 5, 15);

        ctx.strokeStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.moveTo(0, canvas.height);
        ctx.lineTo(canvas.width, 0);
        ctx.stroke();

        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#f00');
        gradient.addColorStop(0.5, '#0f0');
        gradient.addColorStop(1, '#00f');
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.3;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const dataURL = canvas.toDataURL();

        function simpleHash(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0;
          }
          return Math.abs(hash).toString(16);
        }

        return {
          dataURL: dataURL,
          hash: simpleHash(dataURL),
          details: {
            renderer: ctx.getContextAttributes(),
            textMetrics: ctx.measureText('Test'),
            supported: {
              filter: typeof ctx.filter !== 'undefined',
              textDrawing: typeof ctx.fillText !== 'undefined'
            }
          }
        };
      }
    </script>
  </head>
  <body>
    <button id="save-fingerprint-btn" type="button" disabled>сохранить fingerprint</button>
    <p id=content></p>
    <canvas id=canvas> </canvas>
  </body>
</html>
