<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <script type="text/javascript">

      const hashMini = (x) => {
        const json = `${JSON.stringify(x)}`
        const hash = json.split('').reduce((hash, char, i) => {
          return Math.imul(31, hash) + json.charCodeAt(i) | 0
        }, 0x811c9dc5)
        return ('0000000' + (hash >>> 0).toString(16)).substr(-8)
      }

      async function collect_fp() {
        battery = (await navigator?.getBattery?.());

        hasTouch = () => {
          try {
            return 'ontouchstart' in window && !!document.createEvent('TouchEvent')
          } catch (err) {
            return false
          }
        }

        fp = {
          navigator: {
            userAgent: navigator?.userAgent,

            userAgentData: (await navigator?.userAgentData?.getHighEntropyValues(
                ['architecture', 'bitness', 'formFactors', 'fullVersionList', 'model', 'platformVersion', 'uaFullVersion', 'wow64' ])), // brands, mobile, platform

            platform: navigator?.platform,

            webdriver: navigator?.webdriver,
            appVersion: navigator?.appVersion,
            deviceMemory: navigator?.deviceMemory,
            hardwareConcurrency: navigator?.hardwareConcurrency,
            language: navigator?.language,
            languages: navigator?.languages,
            maxTouchPoints: navigator?.maxTouchPoints,
            onLine: navigator?.onLine,

            vendor: navigator?.vendor,

            connection: {
              downlink: navigator?.connection?.downlink,
              downlinkMax: navigator?.connection?.downlinkMax || navigator?.connection?.downlink,
              effectiveType: "k" + navigator?.connection?.effectiveType?.toUpperCase(),
              rtt: navigator?.connection?.rtt,
              saveData: navigator?.connection?.saveData,
              type: navigator?.connection?.type || "unknown",
            },

            plugings: null,
            mimeTypes: null,

            battery: {
              charging: battery?.charging,
              level: battery?.level,
              chargingTime: battery?.chargingTime == Infinity ? 1e308 : battery?.chargingTime,
              dischargingTime: battery?.dischargingTime == Infinity ? 1e308 : battery?.dischargingTime,
            },

            bluetooth: {
              bluetooth: String(navigator.bluetooth),
              availability: (await navigator.bluetooth?.getAvail1ability?.())
            },

            storage: {
              storage: String(navigator.storage),
              quota: (await navigator?.storage?.estimate?.())?.quota,
              usage: (await navigator?.storage?.estimate?.())?.usage,
            },

            mediaDevices: null,

            gpu: {
              info: {},
              features: [],
              limits: {}
            },

            properties: Object.keys(Object.getPrototypeOf(navigator)) // hashMini(properties.join(', ')),
          },

          performance: {
            memory: {
              jsHeapSizeLimit: performance?.memory?.jsHeapSizeLimit,
              totalJSHeapSize: performance?.memory?.totalJSHeapSize,
              usedJSHeapSize: performance?.memory?.usedJSHeapSize,
            }
          },

          screen: {
            orientation: {
              type: screen?.orientation?.type.replace(/-/, "_"),
              angle: screen?.orientation?.angle,
            },
            availHeight: screen.availHeight,
            availWidth: screen.availWidth,
            pixelDepth: screen.pixelDepth,
            height: screen.height,
            width: screen.width,
            availTop: screen.availTop,
            availLeft: screen.availLeft,
            colorDepth: screen.colorDepth,

            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight,
            outerWidth: window.outerWidth,
            outerHeight: window.outerHeight,
            screenX: window.screenX,
            screenY: window.screenY,
            devicePixelRatio: window.devicePixelRatio,

//            physicalPixelWidth: screen.physicalPixelWidth,
//            physicalPixelHeight: screen.physicalPixelHeight,

            visualViewport: {
              width: window.visualViewport?.width,
              height: window.visualViewport?.width,
            },

            domRectViewport: {
               width: document.body.getBoundingClientRect().width,
               height: document.body.getBoundingClientRect().height,
            },

          },

          misc: {
            window_chrome: String(window.chrome),
            chrome_runtime: String(chrome?.runtime),
            chrome_app: String(chrome?.app),
            window_ontouchstart: String(window.ontouchstart),
            touch_event: hasTouch(),
            window_keys: Object.getOwnPropertyNames(window),
          },

          intl: {
            locale: (new Intl.Collator)?.resolvedOptions?.()?.locale,
            toLocaleString_undefined: (1).toLocaleString?.(undefined, { style: 'currency', currency: 'USD', currencyDisplay: 'name'}),
            toLocaleString_lang: (1).toLocaleString?.(navigator.language, { style: 'currency', currency: 'USD', currencyDisplay: 'name'}),

            timezone: Intl.DateTimeFormat()?.resolvedOptions?.().timeZone,
            offset: (new Date()).getTimezoneOffset?.(),
          },

          webgl: {
            parameters: {},
            extensions_gl1: [],
            extensions_gl2: [],
            precisions: {},
          },

          voices: Array.from(speechSynthesis?.getVoices() ||[]).map((voice) => ({
            name: voice.name,
            voiceURI: voice.voiceURI,
            lang: voice.lang,
            localService: voice.localService,
            default: voice.default
          })),

          audioCodecs: {},

          videoCodecs: {},

          webrtc: {
            offer: {
              audio: {
                media_line: null,
                rtpmap_lines: []
              },

              video: {
                media_line: null,
                rtpmap_lines: []
              },
            },

            addresses: null,
            sdp: null,
            connectionLineIpAddress: null,
            candidateIpAddress: null,
          },

          fonts: [],

        };

        fp.navigator.plugins = Array.from(navigator.plugins || []).map((p) => ({
          name: p.name,
          filename: p.filename,
          description: p.description,
          mimeTypes: Array.from(p || []).map(mt => ({
            type: mt.type,
            description: mt.description,
            suffixes: mt.suffixes
          }))
        }));

        fp.navigator.mimeTypes = Array.from(navigator.mimeTypes || []).map(mt => ({
          type: mt.type,
          description: mt.description,
          suffixes: mt.suffixes,
          enabledPlugin: mt.enabledPlugin && mt.enabledPlugin.name ? mt.enabledPlugin.name : null
        }));

        media_devices = await navigator?.mediaDevices?.enumerateDevices?.() || [];

        fp.navigator.mediaDevices = media_devices.map((d) => ({
          deviceId: d.deviceId,
          groupId: d.groupId,
          kind: d.kind,
          label: d.label
        }));

        // webgpu
        gpu_adapter = await navigator.gpu?.requestAdapter?.()

        for (let key in gpu_adapter?.info) {
          fp.navigator.gpu.info[key] = gpu_adapter.info[key]
        }

        for (let key in gpu_adapter?.limits) {
          fp.navigator.gpu.limits[key] = gpu_adapter.limits[key]
        }

        fp.navigator.gpu.features = Array.from(gpu_adapter?.features)

        // webgl
        canvas1 = document.createElement("canvas");
        gl1_context = canvas1.getContext("webgl");
        fp.webgl.extensions_gl1 = gl1_context.getSupportedExtensions();

        canvas2 = document.createElement("canvas");
        gl2_context = canvas2.getContext("webgl2");
        fp.webgl.extensions_gl2 = gl2_context.getSupportedExtensions();

        ["ALIASED_LINE_WIDTH_RANGE", "ALIASED_POINT_SIZE_RANGE"].forEach(key => {
          try {
            range = gl2_context.getParameter(gl2_context[key])
            fp.webgl.parameters[key] = {min: range[0], max: range[1]}
          } catch (e) {
            fp.webgl.parameters[key] = null
          }
        });

        ["MAX_3D_TEXTURE_SIZE", "MAX_ARRAY_TEXTURE_LAYERS",
         "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", "MAX_COLOR_ATTACHMENTS", "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
         "MAX_COMBINED_UNIFORM_BLOCKS", "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", "MAX_CUBE_MAP_TEXTURE_SIZE", "MAX_DRAW_BUFFERS",
         "MAX_ELEMENTS_INDICES", "MAX_ELEMENTS_VERTICES", "MAX_ELEMENT_INDEX", "MAX_FRAGMENT_INPUT_COMPONENTS",
         "MAX_FRAGMENT_UNIFORM_BLOCKS", "MAX_FRAGMENT_UNIFORM_COMPONENTS", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_PROGRAM_TEXEL_OFFSET",
         "MAX_RENDERBUFFER_SIZE", "MAX_SAMPLES", "MAX_SERVER_WAIT_TIMEOUT", "MAX_TEXTURE_IMAGE_UNITS",
         "MAX_TEXTURE_LOD_BIAS", "MAX_TEXTURE_SIZE", "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
         "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", "MAX_UNIFORM_BLOCK_SIZE", "MAX_UNIFORM_BUFFER_BINDINGS",
         "MAX_VARYING_COMPONENTS", "MAX_VARYING_VECTORS", "MAX_VERTEX_ATTRIBS", "MAX_VERTEX_OUTPUT_COMPONENTS",
         "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_VERTEX_UNIFORM_BLOCKS", "MAX_VERTEX_UNIFORM_COMPONENTS", "MAX_VERTEX_UNIFORM_VECTORS",
         "MIN_PROGRAM_TEXEL_OFFSET", ].forEach(key =>
        {
          try {
            fp.webgl.parameters[key] = gl2_context.getParameter(gl2_context[key])
          } catch (e) {
            fp.webgl.parameters[key] = null
          }
        });

        key = "MAX_VIEWPORT_DIMS";
        try {
          dims = gl2_context.getParameter(gl2_context[key])
          fp.webgl.parameters[key] = {width: dims[0], height: dims[1]}
        } catch (e) {
          fp.webgl.parameters[key] = null
        }

        renderer_info = gl1_context.getExtension("WEBGL_debug_renderer_info");

//        try {
          fp.webgl.parameters.UNMASKED_RENDERER_WEBGL = gl1_context.getParameter(renderer_info.UNMASKED_RENDERER_WEBGL)
          fp.webgl.parameters.UNMASKED_VENDOR_WEBGL = gl1_context.getParameter(renderer_info.UNMASKED_VENDOR_WEBGL)
          ani_ext = gl1_context.getExtension('EXT_texture_filter_anisotropic')
          if(ani_ext) {
            fp.webgl.parameters.MAX_TEXTURE_MAX_ANISOTROPY_EXT = gl1_context.getParameter(ani_ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
          } else {
            fp.webgl.parameters.MAX_TEXTURE_MAX_ANISOTROPY_EXT = null
          }
//        } catch (e) {};

        ["VERTEX_SHADER", "FRAGMENT_SHADER"].forEach(shader_type => {
          fp.webgl.precisions[shader_type.toLowerCase()] = {};
          ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"].forEach(precision_type => {
             precision = gl1_context.getShaderPrecisionFormat(gl1_context[shader_type], gl1_context[precision_type])
             fp.webgl.precisions[shader_type.toLowerCase()][precision_type.toLowerCase()] = {
               precision: precision.precision,
               max: precision.rangeMax,
               min: precision.rangeMin,
             }
          });
        });

        // webrtc

        async function get_ice_addresses(connection) {
          return new Promise((resolve) => {
            addresses = []
            setTimeout(() => { return resolve(["timeout"]) }, 3000)

            connection.onicecandidate = (event) => {
              if(event.candidate) {
                addresses.push(event.candidate.address)
              } else {
                connection.onicecandidate = null
                resolve(addresses)
              }
            }
          })
        }

        config = {
          iceCandidatePoolSize: 1,
          iceServers: [{ urls: [ 'stun:stun4.l.google.com:19302', 'stun:stun3.l.google.com:19302']}],
        }

        connection = new RTCPeerConnection(config)
        connection.createDataChannel('')
        offer = await connection.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 })
        connection.setLocalDescription(offer)

        m = offer.sdp.match(new RegExp(/m=audio [^\s]+ [^\s]+ ([^\n|\r]+)/)) || []
        fp.webrtc.offer.audio.media_line = m[0]
        adescs = m[1]?.split(' ')

        adescs?.forEach(adesc => {
          fp.webrtc.offer.audio.rtpmap_lines.push(...(offer.sdp.match(RegExp(`a=(rtpmap|fmtp|rtcp-fb):${adesc} (.+)`, 'g'))))
        });

        m = offer.sdp.match(new RegExp(/m=video [^\s]+ [^\s]+ ([^\n|\r]+)/)) || []
        fp.webrtc.offer.video.media_line = m[0]
        vdescs = m[1]?.split(' ')

        vdescs?.forEach(vdesc => {
          fp.webrtc.offer.video.rtpmap_lines.push(...(offer.sdp.match(RegExp(`a=(rtpmap|fmtp|rtcp-fb):${vdesc} (.+)`, 'g'))))
        })

        ice_promise = get_ice_addresses(connection);

        ice_promise.then((addresses) => {
          fp.webrtc.addresses = addresses
          fp.webrtc.sdp = connection.localDescription.sdp.replace(/http:\/\//g, "http:_/").split(/\r\n/)
          fp.webrtc.connectionLineIpAddress = connection.localDescription.sdp.match(/c=IN\s.+\s/i)?.[0].trim()
          fp.webrtc.candidateIpAddress = connection.localDescription.sdp.match(/(udp|tcp)\s(\d|\w)+\s((\d|\w|(\.|\:))+)(?=\s)/i)?.[0]
          try { connection.close(); } catch(e){}
        });




        // ----

        await Promise.all([ice_promise]);

        return fp;
      }

      document.addEventListener('DOMContentLoaded', async () => {
        const fp = await collect_fp()
        console.log(JSON.stringify(fp, null, 2))

        const save_fp_btn = document.getElementById('save-fingerprint-btn')
        save_fp_btn.disabled = false
        save_fp_btn.addEventListener('click', () => {
          downloadAsFile({id: 777, "fingerprint": fp}, 'fingerprint')
        })

        var content = document.getElementById("content")

        const separator = "<tr><td style='border-top: 10px solid transparent' colspan=2></td></tr>"
        th = function(header) { content.innerHTML = header; return `${separator}<tr><th colspan=2>${header}</th></tr>` }

        str = "<table>"

        str += th("navigator");

        [ "webdriver", "appName", "appVersion", "deviceMemory", "hardwareConcurrency", "language", "languages",
          "maxTouchPoints", "onLine", "platform", "vendor", "userAgent", "userAgentData",
        ].forEach( key => {
          str += `<tr><td>${key}</td> <td>${JSON.stringify(navigator[key])}</td> </tr>`
        })

        str += th("webrtc")

        async function get_ice_addresses(connection) {
          return new Promise((resolve) => {
            addresses = []
            setTimeout(() => { return resolve(["timeout"]) }, 3000)

            connection.addEventListener("icecandidate", (event) => {
              if(event.candidate) {
                addresses.push(event.candidate.address)
              } else {
                resolve(addresses)
              }
            })
          })
        }

        config = {
          iceCandidatePoolSize: 1,
          iceServers: [{ urls: [ 'stun:stun4.l.google.com:19302', 'stun:stun3.l.google.com:19302']}],
        }

        connection = new RTCPeerConnection(config)
        connection.createDataChannel('')
        offer = await connection.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 })
        connection.setLocalDescription(offer)

        addresses = await get_ice_addresses(connection);
        connection.close()

        addresses.forEach( (address, i) => {
          str += `<tr><td>icecandidate[${i}] addr = </td> <td>${address}</td> </tr>`
        })

        connectionLineIpAddress = connection.localDescription.sdp.match(/c=IN\s.+\s/i)?.[0].trim()
        str += `<tr><td>sdp connection addrr = </td> <td>${connectionLineIpAddress}</td> </tr>`

        candidateIpAddress = connection.localDescription.sdp.match(/(udp|tcp)\s(\d|\w)+\s((\d|\w|(\.|\:))+)(?=\s)/i)?.[0]
        str += `<tr><td>sdp candidate addrr = </td> <td>${candidateIpAddress}</td> </tr>`

        str += th(`navigator.plugins: ${navigator.plugins.length}`)

        Array.from(navigator.plugins).forEach((p, i) => {
          str += `<tr><td>plugings[${i}]:</td>
                  <td>name: '${p.name}', filename: '${p.filename}', description: '${p.description}'`;

          Array.from(p).forEach((mt, j) => {
            str += `<br/>MimeType[${j}]: { type: '${mt.type}', description: '${mt.description}', suffixes: '${mt.suffixes}'`
          });

          str +=`</td></tr>`
        });

        str += th(`navigator.mimeTypes: ${navigator.mimeTypes.length}`)

        Array.from(navigator.mimeTypes).forEach((mt, i) => {
          str += `<tr><td>mimeTypes[${i}] </td>
                  <td>type: '${mt.type}', description: '${mt.description}', suffixes: '${mt.suffixes}',
                  enabledPlugin: '${mt.enabledPlugin && mt.enabledPlugin.name ? mt.enabledPlugin.name : null}'</td></tr>`
        });

        str += th(`speechSynthesis.getVoices(): ${speechSynthesis.getVoices().length}`)

        Array.from(speechSynthesis.getVoices()).forEach((voice, i) => {
          str += `<tr><td>speechSynthesis.getVoices[${i}] </td>
                  <td>name: '${voice.name}', voiceURI: '${voice.voiceURI}', lang: '${voice.lang}', localService: '${voice.localService}', default: '${voice.default}'</td></tr>`
        });

        str += th("misc")

        str += `<tr><td>window.chrome</td><td>${JSON.stringify(window.chrome)}</td></tr>`
        str += `<tr><td>chrome.runtime</td><td>${JSON.stringify(chrome.runtime)}</td></tr>`
        str += `<tr><td>chrome.app</td><td>${JSON.stringify(chrome.app)}</td></tr>`

        str += th("navigator.gpu.requestAdapter().info")

        adapter = (await navigator.gpu.requestAdapter());

        for(let key in adapter.info) {
          str += `<tr><td>info.${key} = </td> <td>${adapter.info[key]}</td> </tr>`
        };

        str += th(`navigator.gpu.requestAdapter().limits`);

        for(let key in adapter.limits) {
          str += `<tr><td>${key}: </td> <td>${adapter.limits[key]}</td> </tr>`
        };

        str += th(`navigator.gpu.requestAdapter().features: ${adapter.features.size}`)

        str += `<tr><td colspan=2>${JSON.stringify(Array.from(adapter.features))}</td></tr>`

        str += th("navigator.userAgentData.getHighEntropyValues()")

        var high_entr_fields = ['architecture', 'bitness', 'formFactors', 'fullVersionList', 'model', 'platformVersion', 'uaFullVersion', 'wow64' ]
        high_entr_values = await navigator.userAgentData.getHighEntropyValues(high_entr_fields);
        high_entr_fields.forEach(field => {
          str += `<tr><td>userAgentData.${field} = </td> <td>${JSON.stringify(high_entr_values[field])}</td></tr>`
        })

        str += th("navigator.getBattery()")

        battery = await navigator.getBattery();
        str += `<tr><td>charging: </td><td>${battery.charging}</td></tr>
                <tr><td>level: </td><td>${battery.level}</td></tr>
                <tr><td>chargingTime: </td><td>${battery.chargingTime}</td></tr>
                <tr><td>dischargingTime: </td><td>${battery.dischargingTime}</td></tr>`

        str += th("navigator.storage")

        function getTemporaryStorageUsage() {
          return new Promise((resolve, reject) => {
            navigator.webkitTemporaryStorage.queryUsageAndQuota((usage, quota) => {
              resolve({ usage: usage, quota: quota });
            })
          })
        }

        const { usage, quota } = await getTemporaryStorageUsage();
        str += `<tr><td>webkitTemporaryStorage.queryUsageAndQuota.quota: </td><td>${quota}</td></tr>
                <tr><td>webkitTemporaryStorage.queryUsageAndQuota.usage: </td><td>${usage}</td></tr>`

        str += `<tr><td>storage.estimate().quota: </td><td>${(await navigator.storage.estimate()).quota}</td></tr>
                <tr><td>storage.estimate().usage: </td><td>${(await navigator.storage.estimate()).usage}</td></tr>`

        str += th("navigator.bluetooth")

        str += `<tr><td>navigator.bluetooth: </td><td>${String(navigator.bluetooth)}</td></tr>`
        str += `<tr><td>navigator.bluetooth.getAvailability(): </td><td>${navigator.bluetooth ? (await navigator.bluetooth.getAvailability()) : false }</td></tr>`

        media_devices = await navigator.mediaDevices.enumerateDevices();
        str += th(`navigator.mediaDevices.enumerateDevices(): ${media_devices.length}`)

        media_devices.forEach((device, i) => {
          str += `<tr><td>mediaDevices[${i}] = </td><td>deviceId: '${device.deviceId}', groupId: '${device.groupId}', kind: '${device.kind}', label: '${device.label}'</td></tr>`
        });

        str += th("performance.memory")

        str += `<tr><td>performance.memory.jsHeapSizeLimit: </td><td>${performance.memory.jsHeapSizeLimit}</td></tr>
                <tr><td>performance.memory.totalJSHeapSize: </td><td>${performance.memory.totalJSHeapSize}</td></tr>
                <tr><td>performance.memory.usedJSHeapSize: </td><td>${performance.memory.usedJSHeapSize}</td></tr>`

        str += th(`window`)

        hasTouch = () => {
          try {
            return 'ontouchstart' in window && !!document.createEvent('TouchEvent')
          } catch (err) {
            return false
          }
        }

        str += `<tr><td> window.ontouchstart && !!document.createEvent('TouchEvent'): </td><td>${hasTouch()}</td></tr>`;

        str += separator;

        ["screenLeft", "screenTop", "innerWidth", "innerHeight", "outerWidth", "outerHeight", "devicePixelRatio"].forEach(key => {
          str += `<tr><td>window.${key}: </td><td>${window[key]}</td></tr>`
        });

        str += th("screen");

        ["availLeft", "availTop", "width", "height", "availWidth", "availHeight", "colorDepth", "pixelDepth", "isExtended"].forEach(key => {
          str += `<tr><td>screen.${key}: </td><td>${JSON.stringify(screen[key])}</td></tr>`
        });
        str += `<tr><td>screen.orientation.type: </td><td>${screen.orientation.type}</td></tr>`
        str += `<tr><td>screen.orientation.angle: </td><td>${screen.orientation.angle}</td></tr>`

        // str += th("navigator.geolocation");
        //
        // function getPosition(options) {
        //   return new Promise((resolve, reject) =>
        //     navigator.geolocation.getCurrentPosition(resolve, reject, options));}
        //
        // try {
        //   location = await getPosition({ maximumAge: 10000, timeout: 1000, enableHighAccuracy: true });
        //
        //   str += `
        //       <tr><td>latitude</td><td>${location.coords.latitude}</td></tr>
        //       <tr><td>longitude</td><td>${location.coords.longitude}</td></tr>
        //       <tr><td>altitude</td><td>${location.coords.altitude}</td></tr>
        //       <tr><td>accuracy</td><td>${location.coords.accuracy}</td></tr>
        //       <tr><td>altitudeAccuracy</td><td>${location.coords.altitudeAccuracy}</td></tr>
        //       <tr><td>heading</td><td>${location.coords.heading}</td></tr>
        //       <tr><td>speed</td><td>${location.coords.speed}</td></tr>`;
        // } catch (err) {
        //   console.error('Geolocation error:', err.code, err.message);
        //   str += `<tr><td>navigator.geolocation.getCurrentPosition()</td><td>error: ${err.code} ${err.message}</td></tr>`
        // }

        str += th("webgl");

        canvas = document.getElementById("canvas");
        gl1_context = canvas.getContext("webgl");

        renderer_info = gl1_context.getExtension("WEBGL_debug_renderer_info");

        str += `<tr><td>UNMASKED_VENDOR_WEBGL = </td><td>${gl1_context.getParameter(renderer_info.UNMASKED_VENDOR_WEBGL)}</td></tr>
                <tr><td>UNMASKED_RENDERER_WEBGL = </td><td>${gl1_context.getParameter(renderer_info.UNMASKED_RENDERER_WEBGL)}</td></tr>`

        str += th("webgl1 extensions");

        exts = gl1_context.getSupportedExtensions()
        str += `<tr><td> gl.getSupportedExtensions: ${exts.length} </td><td>${exts.join(', ')}</td></tr>`


        str += th("mime types");

        video = document.createElement('video');
        str += `<tr><td>video.canPlayType('video/not-supported') = </td><td>'${video.canPlayType('video/not-supported')}'</td></tr>
                <tr><td>video.canPlayType('video/h264') = </td><td>'${video.canPlayType('video/h264')}'</td></tr>
                <tr><td>video.canPlayType('video/webm') = </td><td>'${video.canPlayType('video/webm')}'</td></tr>`

        str += separator

        audio = new Audio();
        str += `<tr><td>audio.canPlayType('audio/not-supported') = </td><td>'${audio.canPlayType('audio/not-supported')}'</td></tr>
                <tr><td>audio.canPlayType('audio/ogg') = </td><td>'${audio.canPlayType('audio/ogg')}'</td></tr>
                <tr><td>audio.canPlayType('audio/m4a') = </td><td>'${audio.canPlayType('audio/m4a')}'</td></tr>`

        str += th("intl");

        str += `<tr><td>Intl.DateTimeFormat().resolvedOptions().timeZone: </td><td>${Intl.DateTimeFormat().resolvedOptions().timeZone}</td></tr>
                <tr><td>new Date().getTimezoneOffset() = </td><td>${(new Date().getTimezoneOffset())}</td></tr>
                <tr>
                  <td>(1).toLocaleString(undefined, {style: 'currency'}): </td>
                  <td>${(1).toLocaleString(undefined, { style: 'currency', currency: 'USD', currencyDisplay: 'name'})}</td>
                </tr>
                <tr>
                  <td>(1).toLocaleString(navigator.language, {style: 'currency'}): </td>
                  <td>${(1).toLocaleString(navigator.language, { style: 'currency', currency: 'USD', currencyDisplay: 'name'})}</td>
                </tr>
                <tr>
                  <td>(new Intl.Collator).resolvedOptions().locale: </td><td>${(new Intl.Collator).resolvedOptions().locale}</td>
                </tr>
                `
        str += th("canvas");

        str += "<tr><td><canvas id=canvas_1 width=200 height=50></canvas></td><td id=hash_1></td></tr>"
        str += "<tr><td><canvas id=canvas_2 width=200 height=50></canvas></td><td id=hash_2></td></tr>"

        str += "</table>"

//        results = await getFontFingerprint(fontCandidates)

        results = detectInstalledFonts(fontCandidates)

        console.log("Font Availability:", JSON.stringify(results));

        str += "<table border=1><tr><th>Font</th><th>Available</th></tr>";
        for (const font in results) {
          str +=
            `<tr>
              <td style="font-family:'${font}'">${font}</td>
              <td style="color:${results[font] ? 'green' : 'red'}"> ${results[font] ? "yes" : "no" }</td>
            </tr>`;
        }
        str += '</table>';
        content.innerHTML = str

        fingerprint1 = generateCanvasFingerprint(document.getElementById("canvas_1"));
        prev_fingerprint1_hash = localStorage.getItem("canvasFingerprint1");
        localStorage.setItem("canvasFingerprint1", fingerprint1.hash);
        // console.log('Canvas Fingerprint Hash:', fingerprint1.hash);

        fingerprint2 = generateCanvasFingerprint(document.getElementById("canvas_2"));
        prev_fingerprint2_hash = localStorage.getItem("canvasFingerprint2");
        localStorage.setItem("canvasFingerprint2", fingerprint2.hash);
        // console.log('Canvas Fingerprint Hash:', fingerprint2.hash);


        document.getElementById("hash_1").innerHTML = `current hash = ${fingerprint1.hash} prev hash = ${prev_fingerprint1_hash}`
        document.getElementById("hash_2").innerHTML = `current hash = ${fingerprint2.hash} prev hash = ${prev_fingerprint2_hash}`

      });

      function downloadAsFile(data, name) {
        const json = JSON.stringify(data, null, 2)
        const blob = new Blob([json], { type: 'application/json;charset=utf-8' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `${name}.json`
        document.body.appendChild(a)
        a.click()
        a.remove()
        URL.revokeObjectURL(url)
      }

       const fontCandidates = [
          'Arial', 'Arial Black', 'Arial Narrow', 'Arial Unicode MS',
          'Times New Roman', 'Times', 'Courier New', 'Courier',
          'Liberation Sans', 'Liberation Serif', 'Liberation Mono',
          'DejaVu Sans', 'DejaVu Serif', 'DejaVu Sans Mono',
          'Ubuntu', 'Ubuntu Mono', 'Ubuntu Condensed',
          'Noto Sans Avestan', 'Noto Sans Armenian', 'Noto Sans Cherokee',
          'Chandas', 'Lohit Devanagari', 'FreeMono',
          'Roboto',
            'Roboto Condensed',
            'Roboto Slab',
            'Noto Sans',
            'Noto Serif',
            'Noto Sans CJK JP',
            'Noto Sans CJK KR',
            'Noto Sans CJK SC',
            'Noto Sans Arabic',
            'Droid Sans',
            'Droid Sans Mono',
            'Droid Serif',
            'SamsungOne',
            'Samsung Sans',
            'MiLanProVF',
            'Oppo Sans',
            'LG Smart UI',
            'Helvetica',


  "Roboto Condensed Thin",
  "Roboto Condensed ExtraLight",
  "Roboto Condensed Light",
  "Roboto Condensed Regular",
  "Roboto Condensed Medium",
  "Roboto Condensed SemiBold",
  "Roboto Condensed Bold",
  "Roboto Condensed ExtraBold",
  "Roboto Condensed Black",
  "Roboto Condensed Thin Italic",
  "Roboto Condensed ExtraLight Italic",
  "Roboto Condensed Light Italic",
  "Roboto Condensed Italic",
  "Roboto Condensed Medium Italic",
  "Roboto Condensed SemiBold Italic",
  "Roboto Condensed Bold Italic",
  "Roboto Condensed ExtraBold Italic",
  "Roboto Condensed Black Italic",
  "Droid Sans Mono",
     ];

      async function getFontFingerprint(fontList) {

        const results = {};
        const testString = "mmMwWLliI0O&1";
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        for (const font of fontList) {
          try {
            const fontFace = new FontFace(font, `local("${font}")`);
            await fontFace.load();
            results[font] = fontFace.status === 'loaded';
          } catch {
            results[font] = false;
          }
        }

        // ctx.font = '16px sans-serif';
        // const baseWidth = ctx.measureText(testString).width;
        //
        // for (const font in results) {
        //   if (!results[font]) {
        //     ctx.font = `16px "${font}", sans-serif`;
        //     const testWidth = ctx.measureText(testString).width;
        //     results[font] |= Math.abs(testWidth - baseWidth) > 2;
        //   }
        // }

        return results;
      }


function detectInstalledFonts(fontNames) {
  const testString = 'mmmmmmmmmwwwwwww0123456789абвгдABCD'; // чтобы ширина была чувствительной
  const testSize = '72px'; // побольше — разница заметнее
  const body = document.body || document.documentElement;

  const span = document.createElement('span');
  span.textContent = testString;
  span.style.fontSize = testSize;
  span.style.position = 'absolute';
  span.style.left = '-9999px';
  span.style.top = '-9999px';
  span.style.whiteSpace = 'nowrap';

  const baseMetrics = {};
  body.appendChild(span);

  // Сначала меряем базовые шрифты
  const BASE_FONTS = ['monospace', 'sans-serif', 'serif'];

  BASE_FONTS.forEach(base => {
    span.style.fontFamily = base;
    const rect = span.getBoundingClientRect();
    baseMetrics[base] = { width: rect.width, height: rect.height };
  });

  const result = {};

  fontNames.forEach(name => {
    let isInstalled = false;

    for (const base of BASE_FONTS) {
      span.style.fontFamily = `"${name}",${base}`;
      const rect = span.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const baseRect = baseMetrics[base];
      // Если размеры отличаются от базового — значит, подставился настоящий шрифт
      if (w !== baseRect.width || h !== baseRect.height) {
        isInstalled = true;
        break;
      }
    }

    result[name] = isInstalled;
  });

  span.remove();
  return result;
}

      function generateCanvasFingerprint(canvas) {
        const ctx = canvas.getContext('2d');

        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#069';
        ctx.fillText('Canvas Fingerprint: @' + new Date().toISOString(), 5, 15);

        ctx.strokeStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.moveTo(0, canvas.height);
        ctx.lineTo(canvas.width, 0);
        ctx.stroke();

        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#f00');
        gradient.addColorStop(0.5, '#0f0');
        gradient.addColorStop(1, '#00f');
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.3;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const dataURL = canvas.toDataURL();

        function simpleHash(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0;
          }
          return Math.abs(hash).toString(16);
        }

        return {
          dataURL: dataURL,
          hash: simpleHash(dataURL),
          details: {
            renderer: ctx.getContextAttributes(),
            textMetrics: ctx.measureText('Test'),
            supported: {
              filter: typeof ctx.filter !== 'undefined',
              textDrawing: typeof ctx.fillText !== 'undefined'
            }
          }
        };
      }
    </script>
  </head>
  <body>
    <button id="save-fingerprint-btn" type="button" disabled>сохранить fingerprint</button>
    <p id=content></p>
    <canvas id=canvas> </canvas>
  </body>
</html>
